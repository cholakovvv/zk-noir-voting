{"noir_version":"0.31.0+540bef3597bd3e5775c83ec2ee3c0d4463084b4c","hash":7970268787513018308,"abi":{"parameters":[{"name":"root","type":{"kind":"field"},"visibility":"public"},{"name":"index","type":{"kind":"field"},"visibility":"private"},{"name":"hash_path","type":{"kind":"array","length":2,"type":{"kind":"field"}},"visibility":"private"},{"name":"secret","type":{"kind":"field"},"visibility":"private"},{"name":"proposalId","type":{"kind":"field"},"visibility":"public"},{"name":"vote_commitment","type":{"kind":"field"},"visibility":"public"},{"name":"vote_opening","type":{"kind":"field"},"visibility":"private"},{"name":"salt","type":{"kind":"field"},"visibility":"private"}],"return_type":{"abi_type":{"kind":"field"},"visibility":"public"},"error_types":{}},"bytecode":"H4sIAAAAAAAA/+1abW/aMBC+EKD0fZRS+sLapkzatE9xQsB8619JaPjZ+ynT4nFunGDUCh4zkHaSZZNE9/rcXWzi0ZJ+FiPktVeM42I0+PdRMX4Xo8mzohOqkn72ledwOxJtg1ccTsbjfBrlIhZpGM0ymYTjJJtIIUUik7dIxnEux3I6y2bTcCbGcS4WySxeMLMTnF5hq2avSR7YB0dAvS3qbstb6IXpi1Oezwx/oAS+C1aMfRb2iwX5LPS5JtN3GJQNgRkxMMUp4UB+Rm7Agk5spM3nFl5ZOH9LRDZ5m4o8TeR8PouFiNJJOskiucizRMhEFjznaSQLcVE6F3mYTvIW42gFtIRP7HMcr9DU94IcJp0rR1w44HsJBJkruy/xMbLqiigsSldUIdB8kTH6QtiEUk1D8QyK0WLbd9HxXRVxFM4kz6Yvujxf0Q46fpfKKu2z0KeaTHTHN4OyKVCnzKtLONBf4Wz8+1qr/HYgII/0wqIujLfpix7P17QDkPeoCnIlNKjJ3EOQC/1a2yMcyK/BYAGDOepyvOrdcVu7kYWiB8TJ/25Ykq0b9nm+oR0Uij5VC4USekjdsE84kN/Qv+mGe7Bv1wVOWNR10g0HPN/SDkA+oCrIldCPuiEyKNt2wwFQr1swWNDdsM/xQndDZKEYgDGqTsqbJRQrJ+UtnjtUnpzfUXnCrv1vnqzf02rhQXdWD8frvTA8FGPIuutcfaBq7g5ptWCgG5QHxMoDgFe+WNKQsG8zaEw0jHgR0Icjx3Zvq9+9I7u/ge3W1ATH/R5o81egXkDciEOJRQMYi0dHObxPeVH/p1rhT/XRRyr7qd4QoetlvZ+h/POd9rteDtmnaL4/6DBy9Alo8zNQLyBuxKHEwgfGInCUw/uUF/V6+UzLOhlQWS9fqEroDwAI6JsXcoNTtM3HQJvvwHjQOdnm2WP7fb6nPnjpULlPU9Ti53UPODadV2fYtjjW5mxzE+1Z1uaxs+2+7dqpRU7Xcu3Iomt9o9oxnlfJ8srrcEtSPLRzWxbdmsb9tqGLh9elcoLo06oPuhb/dGq6mbqv+60ooPKwwOQXUAlCrUdgkWt+rdMw+K17xlvD57MY2dTOEdntHNGqnSOLfnU7R/SxnTY+n7XzD2lA1UUTKgAA","debug_symbols":"zdfNboMwDAfwd8mZQ+w4H+6rTNNEWzohVbRq6aSp6rsPOqAbi1Y5XHIj4F/4o1hArmpbrS/vb3WzO5zV6uWq9odN2daHphtdlb6fOh/Lph+d2/LUqpUlV6iq2XZHTLdC7ep9pVbkb8WfUkDNQy1gXzEUI99eCwWx2Z32g3BW/5y9AxgDDDQANmYGjBSQFFgpcFLgpSBIAUsBaLEAsYgvNpuxnzTQnBg5ITmxcuLkxMtJkBMWE9RyEl180BgmQzw3mGBMgqEEYxOMSzA+wYQEw3Jjom0AgDgaCHrJx8HEmwYJJuPtohvEOwx5emrjntzA4ji/tY9SA7EsbsodwiMJ3pOYbJJQNklsNknc4iQBx+mDxydJ/u9Zn1GWkFEWzicL6YyyQEZZMKMsJqMslFEWm1GW+HvX+EcWdr/+SrrBR3mqy/W+6nev/bVLsxk3s92w/Tx+X+lqvwA=","file_map":{"22":{"source":"mod bn254;\nuse bn254::lt as bn254_lt;\n\nimpl Field {\n    pub fn to_le_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_le_bits(bit_size)\n    }\n\n    pub fn to_be_bits(self: Self, bit_size: u32) -> [u1] {\n        crate::assert_constant(bit_size);\n        self.__to_be_bits(bit_size)\n    }\n\n    #[builtin(to_le_bits)]\n    fn __to_le_bits(self, _bit_size: u32) -> [u1] {}\n\n    #[builtin(to_be_bits)]\n    fn __to_be_bits(self, bit_size: u32) -> [u1] {}\n\n    #[builtin(apply_range_constraint)]\n    fn __assert_max_bit_size(self, bit_size: u32) {}\n\n    pub fn assert_max_bit_size(self: Self, bit_size: u32) {\n        crate::assert_constant(bit_size);\n        assert(bit_size < modulus_num_bits() as u32);\n        self.__assert_max_bit_size(bit_size);\n    }\n\n    pub fn to_le_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_le_radix(256, byte_size)\n    }\n\n    pub fn to_be_bytes(self: Self, byte_size: u32) -> [u8] {\n        self.to_be_radix(256, byte_size)\n    }\n\n    pub fn to_le_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_le_radix(radix, result_len)\n    }\n\n    pub fn to_be_radix(self: Self, radix: u32, result_len: u32) -> [u8] {\n        crate::assert_constant(radix);\n        crate::assert_constant(result_len);\n        self.__to_be_radix(radix, result_len)\n    }\n\n    // decompose `_self` into a `_result_len` vector over the `_radix` basis\n    // `_radix` must be less than 256\n    #[builtin(to_le_radix)]\n    fn __to_le_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    #[builtin(to_be_radix)]\n    fn __to_be_radix(self, radix: u32, result_len: u32) -> [u8] {}\n\n    // Returns self to the power of the given exponent value.\n    // Caution: we assume the exponent fits into 32 bits\n    // using a bigger bit size impacts negatively the performance and should be done only if the exponent does not fit in 32 bits\n    pub fn pow_32(self, exponent: Field) -> Field {\n        let mut r: Field = 1;\n        let b = exponent.to_le_bits(32);\n\n        for i in 1..33 {\n            r *= r;\n            r = (b[32-i] as Field) * (r * self) + (1 - b[32-i] as Field) * r;\n        }\n        r\n    }\n\n    // Parity of (prime) Field element, i.e. sgn0(x mod p) = 0 if x âˆˆ {0, ..., p-1} is even, otherwise sgn0(x mod p) = 1.\n    pub fn sgn0(self) -> u1 {\n        self as u1\n    }\n\n    pub fn lt(self, another: Field) -> bool {\n        if crate::compat::is_bn254() {\n            bn254_lt(self, another)\n        } else {\n            lt_fallback(self, another)\n        }\n    }\n}\n\n#[builtin(modulus_num_bits)]\npub fn modulus_num_bits() -> u64 {}\n\n#[builtin(modulus_be_bits)]\npub fn modulus_be_bits() -> [u1] {}\n\n#[builtin(modulus_le_bits)]\npub fn modulus_le_bits() -> [u1] {}\n\n#[builtin(modulus_be_bytes)]\npub fn modulus_be_bytes() -> [u8] {}\n\n#[builtin(modulus_le_bytes)]\npub fn modulus_le_bytes() -> [u8] {}\n// Convert a 32 byte array to a field element by modding\npub fn bytes32_to_field(bytes32: [u8; 32]) -> Field {\n    // Convert it to a field element\n    let mut v = 1;\n    let mut high = 0 as Field;\n    let mut low = 0 as Field;\n\n    for i in 0..16 {\n        high = high + (bytes32[15 - i] as Field) * v;\n        low = low + (bytes32[16 + 15 - i] as Field) * v;\n        v = v * 256;\n    }\n    // Abuse that a % p + b % p = (a + b) % p and that low < p\n    low + high * v\n}\n\nfn lt_fallback(x: Field, y: Field) -> bool {\n    let num_bytes = (modulus_num_bits() as u32 + 7) / 8;\n    let x_bytes = x.to_le_bytes(num_bytes);\n    let y_bytes = y.to_le_bytes(num_bytes);\n    let mut x_is_lt = false;\n    let mut done = false;\n    for i in 0..num_bytes {\n        if (!done) {\n            let x_byte = x_bytes[num_bytes - 1 - i] as u8;\n            let y_byte = y_bytes[num_bytes - 1 - i] as u8;\n            let bytes_match = x_byte == y_byte;\n            if !bytes_match {\n                x_is_lt = x_byte < y_byte;\n                done = true;\n            }\n        }\n    }\n    x_is_lt\n}\n\n","path":"std/field.nr"},"29":{"source":"mod poseidon;\nmod mimc;\nmod poseidon2;\n\nuse crate::default::Default;\nuse crate::uint128::U128;\nuse crate::sha256::{digest, sha256_var};\nuse crate::embedded_curve_ops::EmbeddedCurvePoint;\n\n#[foreign(sha256)]\n// docs:start:sha256\npub fn sha256<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:sha256\n{}\n\n#[foreign(blake2s)]\n// docs:start:blake2s\npub fn blake2s<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake2s\n{}\n\n#[foreign(blake3)]\n// docs:start:blake3\npub fn blake3<N>(input: [u8; N]) -> [u8; 32]\n// docs:end:blake3\n{}\n\n// docs:start:pedersen_commitment\npub fn pedersen_commitment<N>(input: [Field; N]) -> EmbeddedCurvePoint {\n    // docs:end:pedersen_commitment\n    pedersen_commitment_with_separator(input, 0)\n}\n\n#[foreign(pedersen_commitment)]\npub fn __pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> [Field; 2] {}\n\npub fn pedersen_commitment_with_separator<N>(input: [Field; N], separator: u32) -> EmbeddedCurvePoint {\n    let values = __pedersen_commitment_with_separator(input, separator);\n    EmbeddedCurvePoint { x: values[0], y: values[1], is_infinite: false }\n}\n\n// docs:start:pedersen_hash\npub fn pedersen_hash<N>(input: [Field; N]) -> Field\n// docs:end:pedersen_hash\n{\n    pedersen_hash_with_separator(input, 0)\n}\n\n#[foreign(pedersen_hash)]\npub fn pedersen_hash_with_separator<N>(input: [Field; N], separator: u32) -> Field {}\n\npub fn hash_to_field(inputs: [Field]) -> Field {\n    let mut sum = 0;\n\n    for input in inputs {\n        let input_bytes: [u8; 32] = input.to_le_bytes(32).as_array();\n        sum += crate::field::bytes32_to_field(blake2s(input_bytes));\n    }\n\n    sum\n}\n\n#[foreign(keccak256)]\n// docs:start:keccak256\npub fn keccak256<N>(input: [u8; N], message_size: u32) -> [u8; 32]\n// docs:end:keccak256\n{}\n\n#[foreign(poseidon2_permutation)]\npub fn poseidon2_permutation<N>(_input: [Field; N], _state_length: u32) -> [Field; N] {}\n\n#[foreign(sha256_compression)]\npub fn sha256_compression(_input: [u32; 16], _state: [u32; 8]) -> [u32; 8] {}\n\n// Generic hashing support. \n// Partially ported and impacted by rust.\n\n// Hash trait shall be implemented per type.\ntrait Hash{\n    fn hash<H>(self, state: &mut H) where H: Hasher;\n}\n\n// Hasher trait shall be implemented by algorithms to provide hash-agnostic means.\n// TODO: consider making the types generic here ([u8], [Field], etc.)\ntrait Hasher{\n    fn finish(self) -> Field;\n    \n    fn write(&mut self, input: Field);\n}\n\n// BuildHasher is a factory trait, responsible for production of specific Hasher.\ntrait BuildHasher<H> where H: Hasher{\n    fn build_hasher(self) -> H;\n}\n\nstruct BuildHasherDefault<H>;\n\nimpl<H> BuildHasher<H> for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn build_hasher(_self: Self) -> H{\n        H::default()\n    }\n}\n\nimpl<H> Default for BuildHasherDefault<H>\nwhere \n    H: Hasher + Default\n{\n    fn default() -> Self{\n        BuildHasherDefault{}\n    }    \n}\n\nimpl Hash for Field {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self);\n    }\n}\n\nimpl Hash for u8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for u64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i8 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i32 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for i64 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for bool {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self as Field);\n    }\n}\n\nimpl Hash for () {\n    fn hash<H>(_self: Self, _state: &mut H) where H: Hasher {}\n}\n\nimpl Hash for U128 {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        H::write(state, self.lo as Field);\n        H::write(state, self.hi as Field);\n    }\n}\n\nimpl<T, N> Hash for [T; N] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<T> Hash for [T] where T: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.len().hash(state);\n        for elem in self {\n            elem.hash(state);\n        }\n    }\n}\n\nimpl<A, B> Hash for (A, B) where A: Hash, B: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n    }\n}\n\nimpl<A, B, C> Hash for (A, B, C) where A: Hash, B: Hash, C: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n    }\n}\n\nimpl<A, B, C, D> Hash for (A, B, C, D) where A: Hash, B: Hash, C: Hash, D: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n    }\n}\n\nimpl<A, B, C, D, E> Hash for (A, B, C, D, E) where A: Hash, B: Hash, C: Hash, D: Hash, E: Hash {\n    fn hash<H>(self, state: &mut H) where H: Hasher{\n        self.0.hash(state);\n        self.1.hash(state);\n        self.2.hash(state);\n        self.3.hash(state);\n        self.4.hash(state);\n    }\n}\n","path":"std/hash.nr"},"31":{"source":"// Regular merkle tree means a append-only merkle tree (Explain why this is the only way to have privacy and alternatives if you don't want it)\n// Currently we assume that it is a binary tree, so depth k implies a width of 2^k\n// XXX: In the future we can add an arity parameter\n// Returns the merkle root of the tree from the provided leaf, its hashpath, using a pedersen hash function.\npub fn compute_merkle_root<N>(leaf: Field, index: Field, hash_path: [Field; N]) -> Field {\n    let n = hash_path.len();\n    let index_bits = index.to_le_bits(n as u32);\n    let mut current = leaf;\n    for i in 0..n {\n        let path_bit = index_bits[i] as bool;\n        let (hash_left, hash_right) = if path_bit {\n            (hash_path[i], current)\n        } else {\n            (current, hash_path[i])\n        };\n        current = crate::hash::pedersen_hash([hash_left, hash_right]);\n    }\n    current\n}\n","path":"std/merkle.nr"},"47":{"source":"use dep::std;\n\n// Commitment to the vote using Pedersen hash\nfn main(\n    root: pub Field,\n    index: Field,\n    hash_path: [Field; 2],\n    secret: Field,\n    proposalId: pub Field,\n    vote_commitment: pub Field,\n    vote_opening: Field,\n    salt: Field\n) -> pub Field {\n    // Debug outputs\n    // std::println(\"Vote Opening:\");\n    // std::println([vote_opening]);\n    // std::println(\"Secret:\");\n    // std::println([secret]);\n\n    // Verify the vote opening (actual vote and secret) matches the commitment\n    let computed_vote_commitment = std::hash::pedersen_hash([vote_opening, secret]);\n    assert(vote_commitment == computed_vote_commitment);\n    // std::println(\"Vote Commitment:\");\n    // std::println([vote_commitment]);\n    // std::println(\"computed_vote_commitment\");\n    // std::println([computed_vote_commitment]);\n\n    // Cast vote_opening to an integer for comparison\n    let vote_opening_int = vote_opening as i32;\n\n    // Range proof for vote validity (0 or 1)\n    assert(vote_opening_int >= 0);\n    assert(vote_opening_int <= 1);\n\n    // Compute the nullifier using a random salt\n    let nullifier = std::hash::pedersen_hash([root, secret, proposalId, salt]);\n\n    // Merkle tree verification\n    let note_commitment = std::hash::pedersen_hash([secret]);\n    let check_root = std::merkle::compute_merkle_root(note_commitment, index, hash_path);\n    assert(root == check_root);\n\n    nullifier\n}\n\n#[test]\nfn test_valid_build_merkle_tree_and_recursive_proof() {\n    let secret = 1;\n    let salt = 999;\n    let vote_opening = 1;\n    let proposalId = 0;\n\n    let commitment_0 = std::hash::pedersen_hash([secret]);\n    let commitment_1 = std::hash::pedersen_hash([2]);\n    let commitment_2 = std::hash::pedersen_hash([3]);\n    let commitment_3 = std::hash::pedersen_hash([4]);\n\n    let left_branch = std::hash::pedersen_hash([commitment_0, commitment_1]);\n    let right_branch = std::hash::pedersen_hash([commitment_2, commitment_3]);\n\n    let root = std::hash::pedersen_hash([left_branch, right_branch]);\n\n    let vote_commitment = std::hash::pedersen_hash([vote_opening, secret]);\n\n    let nullifier = main(\n        root,\n        0,\n        [commitment_1, right_branch],\n        secret,\n        proposalId,\n        vote_commitment,\n        vote_opening,\n        salt\n    );\n\n    let expected_nullifier = std::hash::pedersen_hash([root, secret, proposalId, salt]);\n\n    assert(nullifier == expected_nullifier);\n}\n","path":"/home/simeon/noir/zkVoting/zk-noir-voting/circuits/src/main.nr"}},"names":["main"]}